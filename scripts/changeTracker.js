// scripts/changeTracker.js - Track translation changes
class ChangeTracker {
    constructor() {
        this.changes = new Map(); // msgid -> { original, translation, language, timestamp }
        this.loadPendingChanges();
    }

    trackChange(language, msgid, originalText, newTranslation, previousTranslation) {
        const changeKey = `${language}:${msgid}`;

        if (newTranslation === previousTranslation) {
            // No actual change, remove from tracking
            this.changes.delete(changeKey);
        } else {
            this.changes.set(changeKey, {
                language,
                msgid,
                originalText,
                previousTranslation: previousTranslation || '',
                newTranslation,
                timestamp: new Date().toISOString(),
                author: this.getCurrentUser()
            });
        }

        this.savePendingChanges();
    }

    getCurrentUser() {
        const auth = AuthManager.getInstance();
        if (auth.authMethod === 'github') {
            // Could fetch GitHub username
            return auth.credentials.username || 'github-user';
        } else {
            return `translator-${auth.credentials.inviteCode.slice(0, 8)}`;
        }
    }

    getChangesByLanguage(language) {
        const languageChanges = [];
        this.changes.forEach((change, key) => {
            if (change.language === language) {
                languageChanges.push(change);
            }
        });
        return languageChanges;
    }

    getAllChanges() {
        return Array.from(this.changes.values());
    }

    clearChanges() {
        this.changes.clear();
        this.savePendingChanges();
    }

    savePendingChanges() {
        const changesArray = Array.from(this.changes.entries());
        localStorage.setItem('pendingTranslationChanges', JSON.stringify(changesArray));
    }

    loadPendingChanges() {
        try {
            const saved = localStorage.getItem('pendingTranslationChanges');
            if (saved) {
                const changesArray = JSON.parse(saved);
                this.changes = new Map(changesArray);
            }
        } catch (error) {
            console.error('Error loading pending changes:', error);
        }
    }

    generatePoFileContent(language, baseContent, changes) {
        // Parse existing PO file
        const messages = this.parsePOFile(baseContent);

        // Apply changes
        changes.forEach(change => {
            if (change.language === language) {
                messages[change.msgid] = change.newTranslation;
            }
        });

        // Generate updated PO file content
        return this.generatePOContent(messages, language);
    }

    parsePOFile(content) {
        // Reuse the parsing logic from translation-tool.html
        const messages = {};
        const lines = content.split('\n');
        let currentMsgid = '';
        let currentMsgstr = '';
        let inMsgid = false;
        let inMsgstr = false;

        for (const line of lines) {
            const trimmed = line.trim();

            if (trimmed.startsWith('msgid ')) {
                if (currentMsgid) {
                    messages[currentMsgid] = currentMsgstr;
                }
                currentMsgid = this.parseQuotedString(trimmed.substring(6));
                currentMsgstr = '';
                inMsgid = true;
                inMsgstr = false;
            } else if (trimmed.startsWith('msgstr ')) {
                currentMsgstr = this.parseQuotedString(trimmed.substring(7));
                inMsgid = false;
                inMsgstr = true;
            } else if (trimmed.startsWith('"')) {
                const continuation = this.parseQuotedString(trimmed);
                if (inMsgid) currentMsgid += continuation;
                else if (inMsgstr) currentMsgstr += continuation;
            }
        }

        if (currentMsgid) {
            messages[currentMsgid] = currentMsgstr;
        }

        delete messages['']; // Remove header
        return messages;
    }

    parseQuotedString(str) {
        str = str.trim();
        if (str.startsWith('"') && str.endsWith('"')) {
            return str.slice(1, -1)
                .replace(/\\"/g, '"')
                .replace(/\\n/g, '\n')
                .replace(/\\t/g, '\t')
                .replace(/\\\\/g, '\\');
        }
        return str;
    }

    generatePOContent(messages, language) {
        const header = `# Translation file for ${language}
# Generated by PO Translation Tool
# Date: ${new Date().toISOString()}

msgid ""
msgstr ""
"Language: ${language}\\n"
"MIME-Version: 1.0\\n"
"Content-Type: text/plain; charset=UTF-8\\n"
"Content-Transfer-Encoding: 8bit\\n"

`;

        let content = header;

        Object.entries(messages).forEach(([msgid, msgstr]) => {
            content += `msgid ${this.escapePoString(msgid)}\n`;
            content += `msgstr ${this.escapePoString(msgstr)}\n\n`;
        });

        return content;
    }

    escapePoString(text) {
        return `"${text
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\t/g, '\\t')}"`;
    }
}